You are a senior Ethereum full-stack dApp engineer and educator. Your task is to build a clean, minimal, but production-style React + JavaScript frontend for a Solidity voting contract called BasicVoting. The smart contract already exists and is deployed; you do not need to rewrite it, only interact with it.

The contract exposes an Admin address, a candidateCount, a totalVotes value, and a public mapping of candidates where each candidate has an id, name, and voteCount. It also provides functions to addCandidate(string _name) (admin-only) and vote(uint _candidateId) (users can vote only once, and invalid votes revert). The compiled ABI is already available locally inside an ABI folder, and you can import it from there without worrying about the exact filename.

Using Vite, React, JavaScript (not TypeScript), ethers.js, and MetaMask, create a frontend that allows users to connect their wallet, read on-chain data from the contract, and display the current list of candidates with their vote counts by reading candidateCount and iterating through the candidates mapping. The app should also display the total number of votes cast. Users should be able to cast a vote for a candidate via MetaMask, with proper handling for pending transactions and state updates once a transaction is confirmed.

If the connected wallet matches the admin address returned by the contract, the UI should additionally expose a simple admin-only form that allows new candidates to be added. Make sure this restriction is enforced at the UI level, but still relies on the contract for final access control.

The React codebase should be modular and well-structured, with clearly separated and reusable components (for example, wallet connection, candidate list, voting actions, and admin controls), and shared Web3 logic extracted into helper modules. All components, hooks, and helpers should be clearly documented with concise comments that explain intent and Web3 behavior, especially around ethers.js usage, contract calls, and signer vs read-only providers.

Environment configuration must be handled securely and correctly by separating backend-only secrets from frontend-safe values. Include a backend .env intended only for Node-based deployment or admin scripts that contains a private key and an RPC or node URL; this private key must never appear in frontend code or frontend environment variables. Separately, include a frontend .env for the Vite app that contains only public-safe values such as the RPC URL and the deployed contract address, which the React app will use to interact with the contract.

Use ethers.js to create both a read-only contract instance backed by an RPC provider and a signer-based contract instance using window.ethereum when MetaMask is connected. Handle common edge cases gracefully, such as MetaMask not being installed, the user not being connected, or the user being on the wrong network, with clear and simple user-facing messages.
